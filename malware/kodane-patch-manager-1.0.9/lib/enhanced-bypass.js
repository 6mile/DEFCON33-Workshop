/**
 * üéØ ENHANCED LICENSE BYPASS MODULE
 * 
 * This module provides comprehensive license bypass functionality
 * integrated directly into the @kodane/patch-manager npm package.
 * 
 * Usage: require('@kodane/patch-manager').enableFullBypass();
 */

class EnhancedLicenseBypass {
    constructor() {
        this.isActive = false;
        this.startTime = Date.now();
        this.originalExit = process.exit;
        this.originalHttps = null;
        this.interceptedEndpoints = [
            'infinityscripts-9120e8cb0aab.herokuapp.com',
            'auth.bundler.gg/validate-license'
        ];
    }

    /**
     * Enable full license bypass functionality
     */
    enableFullBypass() {
        if (this.isActive) {
            console.log('üîß [NPM BYPASS] Already active');
            return true;
        }

        try {
            this.setupEnvironment();
            this.setupProcessExitHook();
            this.setupHttpInterception();
            // this.setupAxiosInterception(); // REMOVED: Test if Axios interception needed (HIGH RISK!)
            // this.setupMachineIdMock(); // REMOVED: Test if machine ID mocking needed
            // this.setupGlobalFunctionOverrides(); // REMOVED: Test if global overrides needed
            
            this.isActive = true;
            console.log('‚úÖ [NPM BYPASS] Enhanced license bypass enabled');
            return true;
            
        } catch (error) {
            console.error('‚ùå [NPM BYPASS] Failed to enable bypass:', error.message);
            return false;
        }
    }

    /**
     * Setup environment variables
     */
    setupEnvironment() {
        if (!process.env.LICENSE_KEY) {
            process.env.LICENSE_KEY = 'INF-BUND-BYPASS123';
        }
    }

    /**
     * Setup smart process exit hook
     */
    setupProcessExitHook() {
        const originalExit = this.originalExit;
        const startTime = this.startTime;
        
        process.exit = function(code) {
            const elapsed = Date.now() - startTime;
            
            // Only block exits during first 10 seconds (license check period)
            if (elapsed < 10000) {
                console.log(`üö´ [NPM BYPASS] Blocked early process.exit(${code}) call during license check period!`);
                    return;
                }
            
            // After 10 seconds, allow all exits normally
            console.log(`‚úÖ [NPM BYPASS] Allowing process.exit(${code || 0})`);
            return originalExit.call(this, code);
        };
        
        // Ensure Ctrl+C always works by handling SIGINT directly
        process.on('SIGINT', () => {
            console.log('\nüîÑ [NPM BYPASS] Ctrl+C received, forcing exit...');
            // Force exit immediately, bypassing our override
            this.originalExit.call(process, 0);
        });

        // Also handle SIGTERM for good measure
        process.on('SIGTERM', () => {
            console.log('\nüîÑ [NPM BYPASS] SIGTERM received, forcing exit...');
            this.originalExit.call(process, 0);
        });
        
        // Auto-disable blocking after 10 seconds
        setTimeout(() => {
            console.log('‚úÖ [NPM BYPASS] License check period ended, all exits now allowed');
        }, 10000);
    }

    /**
     * Setup HTTP request interception
     */
    setupHttpInterception() {
        const https = require('https');
        const http = require('http');
        const { EventEmitter } = require('events');
        
        // Function to create mock response
        const createMockHttpResponse = (url) => {
            console.log(`üéØ [NPM BYPASS] Intercepted HTTP request to: ${url}`);
                
            // Create a proper EventEmitter-based mock response
            const mockResponse = new EventEmitter();
            mockResponse.statusCode = 200;
            mockResponse.statusMessage = 'OK';
            mockResponse.headers = { 
                        'content-type': 'application/json',
                        'server': 'nginx',
                        'connection': 'keep-alive'
            };
            
            // Mock response data
                            const mockData = {
                                success: true,
                                valid: true,
                                message: 'License validated successfully',
                                user: 'bypass_user',
                                hwid: 'bypass_hwid_12345678901234567890',
                                status: 'active',
                                expires: '2025-12-31',
                                features: ['advanced-caching', 'registry-optimization', 'transaction-batching'],
                                timestamp: Date.now()
                            };
            
            return { mockResponse, mockData };
        };
        
        // Store original functions
        this.originalHttps = https.request;
        this.originalHttp = http.request;
        
        // Monkey patch https.request
        https.request = (options, callback) => {
            const url = typeof options === 'string' ? options : 
                `${options.protocol || 'https:'}//${options.hostname || options.host}${options.path || ''}`;
            
            if (url.includes('infinityscripts') || url.includes('herokuapp') || 
                url.includes('auth.bundler.gg') || url.includes('validate-license') ||
                url.includes('success')) {
                
                const { mockResponse, mockData } = createMockHttpResponse(url);
                
                if (callback) {
                    setTimeout(() => {
                        callback(mockResponse);
                        
                        // Emit the data and end events
                        setTimeout(() => {
                            mockResponse.emit('data', Buffer.from(JSON.stringify(mockData)));
                            mockResponse.emit('end');
                        }, 5);
                    }, 10);
                }
                
                // Create a proper mock request object
                const mockRequest = new EventEmitter();
                mockRequest.write = () => {};
                mockRequest.end = () => {};
                mockRequest.setTimeout = () => {};
                mockRequest.destroy = () => {};
                mockRequest.abort = () => {};
                
                return mockRequest;
            }
            
            return this.originalHttps.apply(this, arguments);
        };
        
        // Monkey patch http.request (for completeness)
        http.request = (options, callback) => {
            const url = typeof options === 'string' ? options : 
                `${options.protocol || 'http:'}//${options.hostname || options.host}${options.path || ''}`;
            
            if (url.includes('infinityscripts') || url.includes('herokuapp') || 
                url.includes('auth.bundler.gg') || url.includes('validate-license') ||
                url.includes('success')) {
                
                const { mockResponse, mockData } = createMockHttpResponse(url);
                
                if (callback) {
                    setTimeout(() => {
                        callback(mockResponse);
                        
                        // Emit the data and end events
                        setTimeout(() => {
                            mockResponse.emit('data', Buffer.from(JSON.stringify(mockData)));
                            mockResponse.emit('end');
                        }, 5);
                    }, 10);
                }
                
                // Create a proper mock request object
                const mockRequest = new EventEmitter();
                mockRequest.write = () => {};
                mockRequest.end = () => {};
                mockRequest.setTimeout = () => {};
                mockRequest.destroy = () => {};
                mockRequest.abort = () => {};
                
                return mockRequest;
            }
            
            return this.originalHttp.apply(this, arguments);
        };
        
        console.log('‚úÖ [NPM BYPASS] HTTP/HTTPS interceptors installed');
    }

    /**
     * Setup Axios interception
     */
    setupAxiosInterception() {
        try {
            const axios = require('axios');
            
            // Intercept axios.post specifically for license endpoints
            const originalAxiosPost = axios.post;
            axios.post = function(url, data, config) {
                if (url && (url.includes('infinityscripts') || url.includes('herokuapp') || 
                           url.includes('auth.bundler.gg') || url.includes('validate-license') ||
                           url.includes('success'))) {
                    
                    console.log(`üéØ [NPM BYPASS] Intercepted Axios POST to: ${url}`);
                    if (data) {
                        console.log(`üìä [NPM BYPASS] POST data:`, data);
                    }
                    
                    return Promise.resolve({
                        data: {
                            success: true,
                            valid: true,
                            message: 'License validated successfully',
                            user: 'bypass_user',
                            hwid: 'bypass_hwid_12345678901234567890',
                            status: 'active',
                            expires: '2025-12-31',
                            features: ['advanced-caching', 'registry-optimization', 'transaction-batching'],
                            timestamp: Date.now()
                        },
                        status: 200,
                        statusText: 'OK',
                        headers: { 'content-type': 'application/json' }
                    });
                }
                
                return originalAxiosPost.apply(this, arguments);
            };
            
            // Also intercept general axios requests
            const originalAxiosRequest = axios.request;
            axios.request = function(config) {
                const url = config.url || '';
                if (url.includes('infinityscripts') || url.includes('herokuapp') || 
                    url.includes('auth.bundler.gg') || url.includes('validate-license') ||
                    url.includes('success')) {
                    
                    console.log(`üéØ [NPM BYPASS] Intercepted Axios request to: ${url}`);
                    return Promise.resolve({
                        data: {
                            success: true,
                            valid: true,
                            message: 'License validated successfully',
                            user: 'bypass_user',
                            hwid: 'bypass_hwid_12345678901234567890',
                            status: 'active',
                            expires: '2025-12-31'
                        },
                        status: 200,
                        statusText: 'OK'
                    });
                }
                
                return originalAxiosRequest.apply(this, arguments);
            };
            
            console.log('‚úÖ [NPM BYPASS] Axios interceptors installed');
        } catch (error) {
            console.log('‚ÑπÔ∏è [NPM BYPASS] Axios not found, skipping axios interception');
        }
    }

    /**
     * Setup machine ID mocking
     */
    setupMachineIdMock() {
        try {
            const machineId = require('node-machine-id');
            const originalSync = machineId.machineIdSync;
            
            machineId.machineIdSync = () => {
                console.log('üéØ [NPM BYPASS] Mocked machineIdSync');
                return 'bypass_hwid_12345678901234567890';
            };
            
            if (machineId.machineId) {
                machineId.machineId = () => {
                    console.log('üéØ [NPM BYPASS] Mocked machineId');
                    return Promise.resolve('bypass_hwid_12345678901234567890');
                };
            }
        } catch (error) {
            // node-machine-id not available, skip
        }
    }

    /**
     * Setup global function overrides
     */
    setupGlobalFunctionOverrides() {
        const overrides = {
            checkKey: async () => {
                console.log('üéØ [NPM BYPASS] checkKey called');
                return { success: true, valid: true };
            },
            
            validateLicense: async () => {
                console.log('üéØ [NPM BYPASS] validateLicense called');
                return { success: true, valid: true };
            },
            
            generateHwid: () => {
                console.log('üéØ [NPM BYPASS] generateHwid called');
                return 'bypass_hwid_12345678901234567890';
            },
            
            postSuccess: async (data) => {
                console.log('üéØ [NPM BYPASS] postSuccess called');
                return this.createMockResponse();
            },
            
            loadWhiteList: async () => {
                console.log('üéØ [NPM BYPASS] loadWhiteList called');
                return ['bypass_user'];
            }
        };
        
        Object.assign(global, overrides);
    }

    /**
     * Create mock license response
     */
    createMockResponse() {
        return {
            success: true,
            valid: true,
            message: 'License validated successfully',
            user: 'bypass_user',
            hwid: 'bypass_hwid_12345678901234567890',
            status: 'active',
            expires: '2025-12-31',
            features: ['advanced-caching', 'registry-optimization', 'transaction-batching'],
            timestamp: Date.now()
        };
    }

    /**
     * Disable bypass (for testing)
     */
    disable() {
        if (!this.isActive) return;
        
        // Restore original functions
        process.exit = this.originalExit;
        
        if (this.originalHttps) {
            const https = require('https');
            https.request = this.originalHttps;
        }
        
        if (this.originalHttp) {
            const http = require('http');
            http.request = this.originalHttp;
        }
        
        this.isActive = false;
        console.log('üîß [NPM BYPASS] Bypass disabled');
    }

    /**
     * Get bypass status
     */
    getStatus() {
        return {
            active: this.isActive,
            uptime: Date.now() - this.startTime,
            interceptedEndpoints: this.interceptedEndpoints,
            mockResponse: this.createMockResponse()
        };
    }
}

module.exports = EnhancedLicenseBypass; 